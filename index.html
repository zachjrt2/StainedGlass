<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stained Glass Transformer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }
        
        #app {
            display: flex;
            height: 100vh;
        }
        
        #sidebar {
            width: 320px;
            background: #242424;
            border-right: 1px solid #333;
            overflow-y: auto;
            padding: 20px;
        }
        
        #canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #0a0a0a;
            position: relative;
        }
        
        #renderCanvas {
            max-width: 100%;
            max-height: 100%;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .upload-area {
            border: 2px dashed #555;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 20px;
        }
        
        .upload-area:hover {
            border-color: #888;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .upload-area.dragging {
            border-color: #4a9eff;
            background: rgba(74, 158, 255, 0.1);
        }
        
        #fileInput {
            display: none;
        }
        
        .btn {
            background: #4a9eff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        .btn:hover {
            background: #3a8eef;
        }
        
        .btn:disabled {
            background: #555;
            cursor: not-allowed;
        }
        
        h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #fff;
        }
        
        .status {
            margin-top: 10px;
            font-size: 13px;
            color: #888;
        }
        
        .section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #333;
        }
        
        .section:last-child {
            border-bottom: none;
        }
        
        .slider-group {
            margin-bottom: 15px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 13px;
            color: #ccc;
        }
        
        .slider-value {
            color: #4a9eff;
            font-weight: 600;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4a9eff;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4a9eff;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="sidebar">
            <div class="section">
                <h2>Image Upload</h2>
                <div class="upload-area" id="uploadArea">
                    <div style="font-size: 48px; margin-bottom: 10px;">ðŸ“·</div>
                    <div style="margin-bottom: 10px;">Drag & drop an image here</div>
                    <button class="btn" onclick="document.getElementById('fileInput').click()">
                        Choose File
                    </button>
                    <input type="file" id="fileInput" accept="image/*">
                </div>
                <div class="status" id="uploadStatus">No image loaded</div>
            </div>
            
            <div class="section">
                <h2>Info</h2>
                <div id="imageInfo" style="font-size: 13px; color: #aaa;">
                    Awaiting image upload...
                </div>
            </div>
            
            <div class="section" id="glassSection" style="display: none;">
                <h2>Region Segmentation</h2>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Edge Sensitivity</span>
                        <span class="slider-value" id="edgeSensitivityValue">0.3</span>
                    </div>
                    <input type="range" id="edgeSensitivity" min="0.1" max="0.8" value="0.3" step="0.05">
                </div>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Edge Blur Radius</span>
                        <span class="slider-value" id="edgeBlurValue">1.5</span>
                    </div>
                    <input type="range" id="edgeBlur" min="0" max="5" value="1.5" step="0.5">
                </div>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Min Region Area</span>
                        <span class="slider-value" id="minRegionAreaValue">200</span>
                    </div>
                    <input type="range" id="minRegionArea" min="50" max="1000" value="200" step="50">
                </div>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Max Region Area</span>
                        <span class="slider-value" id="maxRegionAreaValue">5000</span>
                    </div>
                    <input type="range" id="maxRegionArea" min="1000" max="20000" value="5000" step="500">
                </div>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Subdivision Density</span>
                        <span class="slider-value" id="subdivDensityValue">0.5</span>
                    </div>
                    <input type="range" id="subdivDensity" min="0.1" max="1" value="0.5" step="0.05">
                </div>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Subdivision Randomness</span>
                        <span class="slider-value" id="subdivRandomValue">0.4</span>
                    </div>
                    <input type="range" id="subdivRandom" min="0" max="1" value="0.4" step="0.05">
                </div>
                
                <button class="btn" id="regenerateBtn" style="width: 100%; margin-top: 10px;">
                    Regenerate Glass
                </button>
                
                <div class="status" id="processStatus" style="margin-top: 10px;"></div>
            </div>
            
            <div class="section" id="borderSection" style="display: none;">
                <h2>Lead Lines / Borders</h2>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Border Thickness</span>
                        <span class="slider-value" id="borderThicknessValue">3</span>
                    </div>
                    <input type="range" id="borderThickness" min="1" max="10" value="3" step="0.5">
                </div>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Border Irregularity</span>
                        <span class="slider-value" id="borderIrregularityValue">0.3</span>
                    </div>
                    <input type="range" id="borderIrregularity" min="0" max="1" value="0.3" step="0.05">
                </div>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Border Depth</span>
                        <span class="slider-value" id="borderDepthValue">0.5</span>
                    </div>
                    <input type="range" id="borderDepth" min="0" max="1" value="0.5" step="0.05">
                </div>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Border Softness</span>
                        <span class="slider-value" id="borderSoftnessValue">0.4</span>
                    </div>
                    <input type="range" id="borderSoftness" min="0" max="1" value="0.4" step="0.05">
                </div>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Border Brightness</span>
                        <span class="slider-value" id="borderBrightnessValue">0.15</span>
                    </div>
                    <input type="range" id="borderBrightness" min="0" max="0.5" value="0.15" step="0.05">
                </div>
                
                <button class="btn" id="updateBordersBtn" style="width: 100%; margin-top: 10px;">
                    Update Borders
                </button>
            </div>
        </div>
        
        <div id="canvas-container">
            <canvas id="renderCanvas"></canvas>
        </div>
    </div>

    <script type="module">
        // ============================================================================
        // Module: EdgeDetector
        // Detects structural edges in images using Sobel operator
        // ============================================================================
        class EdgeDetector {
            constructor(width, height, imageData) {
                this.width = width;
                this.height = height;
                this.imageData = imageData;
            }
            
            // Apply Gaussian blur to reduce noise before edge detection
            gaussianBlur(imageData, radius) {
                if (radius < 0.5) return imageData;
                
                const width = this.width;
                const height = this.height;
                const src = imageData.data;
                const dst = new Uint8ClampedArray(src.length);
                
                // Generate 1D Gaussian kernel
                const kernelSize = Math.ceil(radius * 3) * 2 + 1;
                const kernel = this.generateGaussianKernel(radius, kernelSize);
                const halfSize = Math.floor(kernelSize / 2);
                
                // Horizontal pass
                const temp = new Uint8ClampedArray(src.length);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let r = 0, g = 0, b = 0;
                        let weightSum = 0;
                        
                        for (let k = 0; k < kernelSize; k++) {
                            const kx = x + k - halfSize;
                            if (kx < 0 || kx >= width) continue;
                            
                            const idx = (y * width + kx) * 4;
                            const weight = kernel[k];
                            
                            r += src[idx] * weight;
                            g += src[idx + 1] * weight;
                            b += src[idx + 2] * weight;
                            weightSum += weight;
                        }
                        
                        const idx = (y * width + x) * 4;
                        temp[idx] = r / weightSum;
                        temp[idx + 1] = g / weightSum;
                        temp[idx + 2] = b / weightSum;
                        temp[idx + 3] = 255;
                    }
                }
                
                // Vertical pass
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let r = 0, g = 0, b = 0;
                        let weightSum = 0;
                        
                        for (let k = 0; k < kernelSize; k++) {
                            const ky = y + k - halfSize;
                            if (ky < 0 || ky >= height) continue;
                            
                            const idx = (ky * width + x) * 4;
                            const weight = kernel[k];
                            
                            r += temp[idx] * weight;
                            g += temp[idx + 1] * weight;
                            b += temp[idx + 2] * weight;
                            weightSum += weight;
                        }
                        
                        const idx = (y * width + x) * 4;
                        dst[idx] = r / weightSum;
                        dst[idx + 1] = g / weightSum;
                        dst[idx + 2] = b / weightSum;
                        dst[idx + 3] = 255;
                    }
                }
                
                return new ImageData(dst, width, height);
            }
            
            generateGaussianKernel(sigma, size) {
                const kernel = new Float32Array(size);
                const center = Math.floor(size / 2);
                let sum = 0;
                
                for (let i = 0; i < size; i++) {
                    const x = i - center;
                    kernel[i] = Math.exp(-(x * x) / (2 * sigma * sigma));
                    sum += kernel[i];
                }
                
                // Normalize
                for (let i = 0; i < size; i++) {
                    kernel[i] /= sum;
                }
                
                return kernel;
            }
            
            // Compute edge magnitude using Sobel operator
            detectEdges(sensitivity, blurRadius) {
                console.log(`Detecting edges (sensitivity: ${sensitivity}, blur: ${blurRadius})`);
                
                // Step 1: Blur if needed
                let workingData = this.imageData;
                if (blurRadius > 0) {
                    workingData = this.gaussianBlur(this.imageData, blurRadius);
                }
                
                const src = workingData.data;
                const edgeMap = new Float32Array(this.width * this.height);
                
                // Sobel kernels
                const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
                const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
                
                // Step 2: Apply Sobel operator
                for (let y = 1; y < this.height - 1; y++) {
                    for (let x = 1; x < this.width - 1; x++) {
                        let gx = 0, gy = 0;
                        
                        // Apply kernels in 3x3 neighborhood
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const px = x + kx;
                                const py = y + ky;
                                const idx = (py * this.width + px) * 4;
                                
                                // Use luminance as edge intensity
                                const lum = 0.299 * src[idx] + 0.587 * src[idx + 1] + 0.114 * src[idx + 2];
                                
                                const kernelIdx = (ky + 1) * 3 + (kx + 1);
                                gx += lum * sobelX[kernelIdx];
                                gy += lum * sobelY[kernelIdx];
                            }
                        }
                        
                        // Edge magnitude
                        const magnitude = Math.sqrt(gx * gx + gy * gy);
                        edgeMap[y * this.width + x] = magnitude;
                    }
                }
                
                // Step 3: Normalize and threshold
                let maxMag = 0;
                for (let i = 0; i < edgeMap.length; i++) {
                    if (edgeMap[i] > maxMag) maxMag = edgeMap[i];
                }
                
                const threshold = sensitivity * maxMag;
                const binaryEdges = new Uint8Array(this.width * this.height);
                
                for (let i = 0; i < edgeMap.length; i++) {
                    binaryEdges[i] = edgeMap[i] > threshold ? 1 : 0;
                }
                
                console.log(`Edge detection complete (max magnitude: ${maxMag.toFixed(1)})`);
                
                return binaryEdges;
            }
        }

        // ============================================================================
        // Module: RegionExtractor
        // Extracts regions from edge map using flood fill
        // ============================================================================
        class RegionExtractor {
            constructor(width, height, imageData) {
                this.width = width;
                this.height = height;
                this.imageData = imageData;
            }
            
            // Extract regions from edge map using flood fill
            extractRegions(edgeMap, minArea) {
                console.log(`Extracting regions (minArea: ${minArea})`);
                
                const regionMap = new Uint16Array(this.width * this.height);
                const regions = [];
                let regionId = 1;
                
                // Flood fill from each unassigned non-edge pixel
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const idx = y * this.width + x;
                        
                        // Skip if edge or already assigned
                        if (edgeMap[idx] === 1 || regionMap[idx] !== 0) continue;
                        
                        // Start new region
                        const region = this.floodFill(x, y, regionId, edgeMap, regionMap);
                        
                        // Only keep regions above minimum area
                        if (region.pixels.length >= minArea) {
                            regions.push(region);
                            regionId++;
                        } else {
                            // Mark as edge to prevent tiny regions
                            for (const pixel of region.pixels) {
                                regionMap[pixel.y * this.width + pixel.x] = 0;
                            }
                        }
                    }
                }
                
                // Assign tiny regions to nearest valid region
                this.assignOrphans(regionMap, regions);
                
                // Extract color data for each region
                this.extractRegionColors(regions);
                
                console.log(`Extracted ${regions.length} regions`);
                
                return { regions, regionMap };
            }
            
            floodFill(startX, startY, regionId, edgeMap, regionMap) {
                const region = {
                    id: regionId,
                    pixels: [],
                    bounds: { minX: startX, minY: startY, maxX: startX, maxY: startY },
                    color: { r: 0, g: 0, b: 0 },
                    area: 0,
                    colorVariance: 0
                };
                
                const stack = [{ x: startX, y: startY }];
                const visited = new Set();
                visited.add(startY * this.width + startX);
                
                while (stack.length > 0) {
                    const { x, y } = stack.pop();
                    const idx = y * this.width + x;
                    
                    // Mark as part of this region
                    regionMap[idx] = regionId;
                    region.pixels.push({ x, y });
                    
                    // Update bounds
                    region.bounds.minX = Math.min(region.bounds.minX, x);
                    region.bounds.minY = Math.min(region.bounds.minY, y);
                    region.bounds.maxX = Math.max(region.bounds.maxX, x);
                    region.bounds.maxY = Math.max(region.bounds.maxY, y);
                    
                    // Check 4-connected neighbors
                    const neighbors = [
                        { x: x + 1, y },
                        { x: x - 1, y },
                        { x, y: y + 1 },
                        { x, y: y - 1 }
                    ];
                    
                    for (const n of neighbors) {
                        if (n.x < 0 || n.x >= this.width || n.y < 0 || n.y >= this.height) continue;
                        
                        const nIdx = n.y * this.width + n.x;
                        if (visited.has(nIdx)) continue;
                        if (edgeMap[nIdx] === 1) continue;
                        if (regionMap[nIdx] !== 0) continue;
                        
                        visited.add(nIdx);
                        stack.push(n);
                    }
                }
                
                region.area = region.pixels.length;
                return region;
            }
            
            assignOrphans(regionMap, regions) {
                // Find all unassigned pixels
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const idx = y * this.width + x;
                        if (regionMap[idx] !== 0) continue;
                        
                        // Find nearest region
                        let minDist = Infinity;
                        let nearestRegion = 1;
                        
                        for (const region of regions) {
                            // Check distance to region bounds (quick approximation)
                            const dx = Math.max(0, region.bounds.minX - x, x - region.bounds.maxX);
                            const dy = Math.max(0, region.bounds.minY - y, y - region.bounds.maxY);
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < minDist) {
                                minDist = dist;
                                nearestRegion = region.id;
                            }
                        }
                        
                        regionMap[idx] = nearestRegion;
                        
                        // Add to region pixels
                        const region = regions.find(r => r.id === nearestRegion);
                        if (region) {
                            region.pixels.push({ x, y });
                            region.area++;
                        }
                    }
                }
            }
            
            extractRegionColors(regions) {
                const data = this.imageData.data;
                
                for (const region of regions) {
                    let sumR = 0, sumG = 0, sumB = 0;
                    
                    // Compute average color
                    for (const pixel of region.pixels) {
                        const idx = (pixel.y * this.width + pixel.x) * 4;
                        sumR += data[idx];
                        sumG += data[idx + 1];
                        sumB += data[idx + 2];
                    }
                    
                    const count = region.pixels.length;
                    region.color.r = Math.round(sumR / count);
                    region.color.g = Math.round(sumG / count);
                    region.color.b = Math.round(sumB / count);
                    
                    // Compute color variance
                    let variance = 0;
                    for (const pixel of region.pixels) {
                        const idx = (pixel.y * this.width + pixel.x) * 4;
                        const dr = data[idx] - region.color.r;
                        const dg = data[idx + 1] - region.color.g;
                        const db = data[idx + 2] - region.color.b;
                        variance += dr * dr + dg * dg + db * db;
                    }
                    region.colorVariance = variance / count;
                }
            }
        }

        // ============================================================================
        // Module: RegionSubdivider
        // Subdivides large regions while preserving boundaries
        // ============================================================================
        class RegionSubdivider {
            constructor(width, height) {
                this.width = width;
                this.height = height;
            }
            
            // Subdivide regions exceeding max area
            subdivideRegions(regions, regionMap, maxArea, density, randomness, seed) {
                console.log(`Subdividing regions (maxArea: ${maxArea}, density: ${density})`);
                
                const random = new Random(seed);
                const newRegions = [];
                let nextId = regions.length + 1;
                
                for (const region of regions) {
                    if (region.area <= maxArea) {
                        // Keep as-is
                        newRegions.push(region);
                    } else {
                        // Subdivide this region
                        const subRegions = this.subdivideRegion(
                            region, regionMap, density, randomness, random, nextId
                        );
                        
                        newRegions.push(...subRegions);
                        nextId += subRegions.length;
                    }
                }
                
                console.log(`Subdivision complete: ${regions.length} -> ${newRegions.length} regions`);
                
                return newRegions;
            }
            
            subdivideRegion(region, regionMap, density, randomness, random, startId) {
                // Calculate number of subdivisions based on area and density
                const targetSubdivisions = Math.ceil(Math.sqrt(region.area / 1000) * density * 5);
                const numSites = Math.max(2, targetSubdivisions);
                
                // Generate site points within region bounds
                const sites = this.generateConstrainedSites(region, numSites, randomness, random);
                
                // Assign each pixel in region to nearest site
                const subRegionMap = new Map();
                
                for (const pixel of region.pixels) {
                    let nearestSite = 0;
                    let minDist = Infinity;
                    
                    for (let i = 0; i < sites.length; i++) {
                        const dx = pixel.x - sites[i].x;
                        const dy = pixel.y - sites[i].y;
                        const dist = dx * dx + dy * dy;
                        
                        if (dist < minDist) {
                            minDist = dist;
                            nearestSite = i;
                        }
                    }
                    
                    if (!subRegionMap.has(nearestSite)) {
                        subRegionMap.set(nearestSite, []);
                    }
                    subRegionMap.get(nearestSite).push(pixel);
                }
                
                // Build sub-regions
                const subRegions = [];
                let subId = startId;
                
                for (const [siteIdx, pixels] of subRegionMap.entries()) {
                    const subRegion = {
                        id: subId++,
                        pixels,
                        bounds: this.computeBounds(pixels),
                        color: { r: 0, g: 0, b: 0 },
                        area: pixels.length,
                        colorVariance: 0,
                        site: sites[siteIdx]
                    };
                    
                    // Update region map
                    for (const pixel of pixels) {
                        regionMap[pixel.y * this.width + pixel.x] = subRegion.id;
                    }
                    
                    subRegions.push(subRegion);
                }
                
                return subRegions;
            }
            
            generateConstrainedSites(region, count, randomness, random) {
                const sites = [];
                const bounds = region.bounds;
                const width = bounds.maxX - bounds.minX + 1;
                const height = bounds.maxY - bounds.minY + 1;
                
                // Grid-based placement with jitter
                const cols = Math.ceil(Math.sqrt(count * width / height));
                const rows = Math.ceil(count / cols);
                const cellW = width / cols;
                const cellH = height / rows;
                
                for (let row = 0; row < rows && sites.length < count; row++) {
                    for (let col = 0; col < cols && sites.length < count; col++) {
                        const baseX = bounds.minX + (col + 0.5) * cellW;
                        const baseY = bounds.minY + (row + 0.5) * cellH;
                        
                        const jitter = randomness * 0.4;
                        const offsetX = (random.next() - 0.5) * cellW * jitter;
                        const offsetY = (random.next() - 0.5) * cellH * jitter;
                        
                        const x = Math.round(Math.max(bounds.minX, Math.min(bounds.maxX, baseX + offsetX)));
                        const y = Math.round(Math.max(bounds.minY, Math.min(bounds.maxY, baseY + offsetY)));
                        
                        // Verify point is actually in region
                        const pixelInRegion = region.pixels.some(p => p.x === x && p.y === y);
                        if (pixelInRegion) {
                            sites.push(new Vec2(x, y));
                        } else {
                            // Use center point if jittered location is outside
                            const centerPixel = region.pixels[Math.floor(region.pixels.length / 2)];
                            sites.push(new Vec2(centerPixel.x, centerPixel.y));
                        }
                    }
                }
                
                return sites;
            }
            
            computeBounds(pixels) {
                const bounds = {
                    minX: Infinity,
                    minY: Infinity,
                    maxX: -Infinity,
                    maxY: -Infinity
                };
                
                for (const pixel of pixels) {
                    bounds.minX = Math.min(bounds.minX, pixel.x);
                    bounds.minY = Math.min(bounds.minY, pixel.y);
                    bounds.maxX = Math.max(bounds.maxX, pixel.x);
                    bounds.maxY = Math.max(bounds.maxY, pixel.y);
                }
                
                return bounds;
            }
        }

        // ============================================================================
        // Module: RegionSegmenter (replaces CellSegmenter)
        // Orchestrates edge-aware region-based segmentation
        // ============================================================================
        class RegionSegmenter {
            constructor(width, height, imageData) {
                this.width = width;
                this.height = height;
                this.imageData = imageData;
                
                this.edgeDetector = new EdgeDetector(width, height, imageData);
                this.regionExtractor = new RegionExtractor(width, height, imageData);
                this.regionSubdivider = new RegionSubdivider(width, height);
            }
            
            // Main segmentation pipeline
            segment(params) {
                console.log('Starting edge-aware segmentation:', params);
                
                // Step 1: Detect edges
                const edgeMap = this.edgeDetector.detectEdges(
                    params.edgeSensitivity,
                    params.edgeBlur
                );
                
                // Step 2: Extract base regions from edge map
                const { regions: baseRegions, regionMap } = this.regionExtractor.extractRegions(
                    edgeMap,
                    params.minRegionArea
                );
                
                // Step 3: Subdivide large regions
                const finalRegions = this.regionSubdivider.subdivideRegions(
                    baseRegions,
                    regionMap,
                    params.maxRegionArea,
                    params.subdivDensity,
                    params.subdivRandom,
                    params.seed
                );
                
                // Step 4: Re-extract colors after subdivision
                this.regionExtractor.extractRegionColors(finalRegions);
                
                // Convert to cell format for compatibility with existing rendering
                const cells = this.convertRegionsToCells(finalRegions);
                
                console.log(`Segmentation complete: ${cells.length} glass pieces`);
                
                return { cells, cellMap: regionMap };
            }
            
            // Convert region format to cell format for rendering compatibility
            convertRegionsToCells(regions) {
                return regions.map(region => ({
                    site: region.site || new Vec2(
                        (region.bounds.minX + region.bounds.maxX) / 2,
                        (region.bounds.minY + region.bounds.maxY) / 2
                    ),
                    index: region.id - 1,
                    pixels: region.pixels,
                    color: region.color,
                    bounds: region.bounds,
                    area: region.area,
                    colorVariance: region.colorVariance
                }));
            }
        }

        // ============================================================================
        // Module: DistanceField
        // Computes distance fields for smooth borders and effects
        // ============================================================================
        class DistanceField {
            constructor(width, height) {
                this.width = width;
                this.height = height;
            }
            
            // Compute distance to nearest cell boundary for each pixel
            // Returns normalized distance (0 at border, 1 at cell center)
            computeBorderDistanceField(cellMap) {
                const distances = new Float32Array(this.width * this.height);
                
                // First pass: mark border pixels
                const isBorder = new Uint8Array(this.width * this.height);
                
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const idx = y * this.width + x;
                        const cellIdx = cellMap[idx];
                        
                        // Check 4-connected neighbors
                        let hasDifferentNeighbor = false;
                        
                        if (x > 0 && cellMap[idx - 1] !== cellIdx) hasDifferentNeighbor = true;
                        if (x < this.width - 1 && cellMap[idx + 1] !== cellIdx) hasDifferentNeighbor = true;
                        if (y > 0 && cellMap[idx - this.width] !== cellIdx) hasDifferentNeighbor = true;
                        if (y < this.height - 1 && cellMap[idx + this.width] !== cellIdx) hasDifferentNeighbor = true;
                        
                        isBorder[idx] = hasDifferentNeighbor ? 1 : 0;
                        distances[idx] = hasDifferentNeighbor ? 0 : Infinity;
                    }
                }
                
                // Distance transform using jump flooding algorithm (approximate but fast)
                this.jumpFloodingDistance(distances, isBorder);
                
                // Normalize distances
                this.normalizeDistances(distances);
                
                return distances;
            }
            
            // Jump flooding algorithm for fast distance field computation
            jumpFloodingDistance(distances, isBorder) {
                const closest = new Int32Array(this.width * this.height);
                
                // Initialize with border positions
                for (let i = 0; i < distances.length; i++) {
                    closest[i] = isBorder[i] ? i : -1;
                }
                
                // Jump flooding passes
                const maxDim = Math.max(this.width, this.height);
                let step = Math.pow(2, Math.ceil(Math.log2(maxDim)) - 1);
                
                while (step >= 1) {
                    this.jumpFloodingPass(closest, distances, step);
                    step = Math.floor(step / 2);
                }
                
                // Final pass with step 1
                this.jumpFloodingPass(closest, distances, 1);
            }
            
            jumpFloodingPass(closest, distances, step) {
                const newClosest = new Int32Array(closest);
                
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const idx = y * this.width + x;
                        
                        // Check neighbors at step distance
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx * step;
                                const ny = y + dy * step;
                                
                                if (nx < 0 || nx >= this.width || ny < 0 || ny >= this.height) continue;
                                
                                const nIdx = ny * this.width + nx;
                                const seedIdx = closest[nIdx];
                                
                                if (seedIdx === -1) continue;
                                
                                // Compute distance to this seed
                                const seedX = seedIdx % this.width;
                                const seedY = Math.floor(seedIdx / this.width);
                                const dist = Math.sqrt((x - seedX) ** 2 + (y - seedY) ** 2);
                                
                                if (dist < distances[idx]) {
                                    distances[idx] = dist;
                                    newClosest[idx] = seedIdx;
                                }
                            }
                        }
                    }
                }
                
                closest.set(newClosest);
            }
            
            normalizeDistances(distances) {
                // Find max distance for normalization
                let maxDist = 0;
                for (let i = 0; i < distances.length; i++) {
                    if (distances[i] !== Infinity && distances[i] > maxDist) {
                        maxDist = distances[i];
                    }
                }
                
                // Normalize to 0-1 range
                if (maxDist > 0) {
                    for (let i = 0; i < distances.length; i++) {
                        if (distances[i] === Infinity) {
                            distances[i] = 1.0;
                        } else {
                            distances[i] = Math.min(1.0, distances[i] / maxDist);
                        }
                    }
                }
            }
        }

        // ============================================================================
        // Module: NoiseGenerator
        // Generates Perlin/Simplex-style noise for organic variation
        // ============================================================================
        class NoiseGenerator {
            constructor(seed = 0) {
                this.seed = seed;
                this.perm = this.generatePermutation();
            }
            
            generatePermutation() {
                const p = [];
                for (let i = 0; i < 256; i++) p[i] = i;
                
                // Fisher-Yates shuffle with seed
                const random = new Random(this.seed);
                for (let i = 255; i > 0; i--) {
                    const j = random.int(0, i);
                    [p[i], p[j]] = [p[j], p[i]];
                }
                
                // Duplicate for wrapping
                return [...p, ...p];
            }
            
            // 2D Perlin-style noise
            noise2D(x, y) {
                // Scale input
                x *= 0.1;
                y *= 0.1;
                
                // Integer coordinates
                const xi = Math.floor(x) & 255;
                const yi = Math.floor(y) & 255;
                
                // Fractional coordinates
                const xf = x - Math.floor(x);
                const yf = y - Math.floor(y);
                
                // Fade curves
                const u = this.fade(xf);
                const v = this.fade(yf);
                
                // Hash coordinates
                const aa = this.perm[this.perm[xi] + yi];
                const ab = this.perm[this.perm[xi] + yi + 1];
                const ba = this.perm[this.perm[xi + 1] + yi];
                const bb = this.perm[this.perm[xi + 1] + yi + 1];
                
                // Gradients
                const g1 = this.grad2D(aa, xf, yf);
                const g2 = this.grad2D(ba, xf - 1, yf);
                const g3 = this.grad2D(ab, xf, yf - 1);
                const g4 = this.grad2D(bb, xf - 1, yf - 1);
                
                // Bilinear interpolation
                const x1 = this.lerp(g1, g2, u);
                const x2 = this.lerp(g3, g4, u);
                
                return this.lerp(x1, x2, v);
            }
            
            grad2D(hash, x, y) {
                const h = hash & 3;
                const u = h < 2 ? x : y;
                const v = h < 2 ? y : x;
                return ((h & 1) ? -u : u) + ((h & 2) ? -2.0 * v : 2.0 * v);
            }
            
            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }
            
            lerp(a, b, t) {
                return a + t * (b - a);
            }
            
            // Octave noise for more detail
            octaveNoise2D(x, y, octaves = 4, persistence = 0.5) {
                let total = 0;
                let frequency = 1;
                let amplitude = 1;
                let maxValue = 0;
                
                for (let i = 0; i < octaves; i++) {
                    total += this.noise2D(x * frequency, y * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= 2;
                }
                
                return total / maxValue;
            }
        }

        // ============================================================================
        // Module: BorderRenderer
        // Advanced border rendering with distance fields and organic variation
        // ============================================================================
        class BorderRenderer {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.distanceField = new DistanceField(width, height);
                this.noiseGen = null;
            }
            
            setRandomSeed(seed) {
                this.noiseGen = new NoiseGenerator(seed);
            }
            
            // Compute border data that can be reused for rendering
            computeBorderData(cellMap, params) {
                const borderData = {
                    distanceField: this.distanceField.computeBorderDistanceField(cellMap),
                    params: { ...params }
                };
                
                return borderData;
            }
            
            // Render borders onto image data
            renderBorders(imageData, cells, cellMap, borderData, params) {
                const data = imageData.data;
                const distances = borderData.distanceField;
                
                const thickness = params.borderThickness;
                const irregularity = params.borderIrregularity;
                const depth = params.borderDepth;
                const softness = params.borderSoftness;
                const brightness = params.borderBrightness;
                
                // Process each pixel
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const idx = y * this.width + x;
                        const pixelIdx = idx * 4;
                        
                        // Get base distance
                        let dist = distances[idx];
                        
                        // Add noise-based irregularity
                        if (irregularity > 0 && this.noiseGen) {
                            const noise = this.noiseGen.octaveNoise2D(x, y, 3, 0.5);
                            dist += noise * irregularity * 0.3;
                        }
                        
                        // Compute border intensity based on distance
                        const borderThreshold = thickness / 100.0; // Normalize thickness
                        let borderAlpha = 0;
                        
                        if (dist < borderThreshold) {
                            // Inside border region
                            const t = dist / borderThreshold;
                            
                            // Apply softness to edge falloff
                            const softT = softness > 0 ? 
                                Math.pow(t, 1 + softness * 3) : t;
                            
                            borderAlpha = 1 - softT;
                        }
                        
                        if (borderAlpha > 0.01) {
                            // Get cell color
                            const cellIdx = cellMap[idx];
                            const cell = cells[cellIdx];
                            
                            // Compute border color with depth/shadow
                            const shadowAmount = depth * (1 - dist / borderThreshold);
                            
                            // Base lead color (dark gray/black)
                            const baseR = brightness * 255;
                            const baseG = brightness * 255;
                            const baseB = brightness * 255;
                            
                            // Add slight color tint from glass
                            const tintAmount = 0.1;
                            const leadR = baseR + cell.color.r * tintAmount;
                            const leadG = baseG + cell.color.g * tintAmount;
                            const leadB = baseB + cell.color.b * tintAmount;
                            
                            // Apply shadow (darken further based on depth)
                            const shadowFactor = 1 - shadowAmount * 0.5;
                            const finalR = leadR * shadowFactor;
                            const finalG = leadG * shadowFactor;
                            const finalB = leadB * shadowFactor;
                            
                            // Blend with existing color
                            data[pixelIdx] = data[pixelIdx] * (1 - borderAlpha) + finalR * borderAlpha;
                            data[pixelIdx + 1] = data[pixelIdx + 1] * (1 - borderAlpha) + finalG * borderAlpha;
                            data[pixelIdx + 2] = data[pixelIdx + 2] * (1 - borderAlpha) + finalB * borderAlpha;
                        }
                    }
                }
            }
        }
        // Module: StainedGlassRenderer
        // Renders the stained glass effect to canvas
        // ============================================================================
        class StainedGlassRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
            }
            
            // Render basic flat stained glass (Phase 2 - simple version)
            renderBasic(width, height, cells, cellMap) {
                this.canvas.width = width;
                this.canvas.height = height;
                
                const imageData = this.ctx.createImageData(width, height);
                const data = imageData.data;
                
                // Fill each pixel with its cell color
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const mapIdx = y * width + x;
                        const cellIdx = cellMap[mapIdx];
                        const cell = cells[cellIdx];
                        const pixelIdx = mapIdx * 4;
                        
                        data[pixelIdx] = cell.color.r;
                        data[pixelIdx + 1] = cell.color.g;
                        data[pixelIdx + 2] = cell.color.b;
                        data[pixelIdx + 3] = 255;
                    }
                }
                
                this.ctx.putImageData(imageData, 0, 0);
                
                // Draw cell borders (lead lines) - simple version
                this.drawBorders(cells, cellMap, width, height);
            }
            
            drawBorders(cells, cellMap, width, height) {
                this.ctx.strokeStyle = '#1a1a1a';
                this.ctx.lineWidth = 2;
                
                // Find border pixels using edge detection
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = y * width + x;
                        const cellIdx = cellMap[idx];
                        
                        // Check neighbors
                        const rightIdx = cellMap[y * width + (x + 1)];
                        const bottomIdx = cellMap[(y + 1) * width + x];
                        
                        if (cellIdx !== rightIdx || cellIdx !== bottomIdx) {
                            this.ctx.fillStyle = '#1a1a1a';
                            this.ctx.fillRect(x, y, 1, 1);
                        }
                    }
                }
            }
        }
        // Module: Utilities
        // Helper functions for math and random number generation
        // ============================================================================
        class Random {
            constructor(seed = Date.now()) {
                this.seed = seed;
            }
            
            // Linear congruential generator
            next() {
                this.seed = (this.seed * 1664525 + 1013904223) % 4294967296;
                return this.seed / 4294967296;
            }
            
            range(min, max) {
                return min + this.next() * (max - min);
            }
            
            int(min, max) {
                return Math.floor(this.range(min, max + 1));
            }
        }
        
        class Vec2 {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            
            distanceTo(other) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            add(other) {
                return new Vec2(this.x + other.x, this.y + other.y);
            }
            
            scale(s) {
                return new Vec2(this.x * s, this.y * s);
            }
        }

        // ============================================================================
        // Module: VoronoiGenerator
        // Generates Voronoi diagrams for glass cell segmentation
        // ============================================================================
        class VoronoiGenerator {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.sites = [];
            }
            
            // Generate site points using various distribution strategies
            generateSites(count, uniformity, minDistance, seed) {
                const random = new Random(seed);
                this.sites = [];
                
                // Mix of uniform grid and random placement based on uniformity
                // uniformity 0 = pure random, 1 = pure grid
                
                if (uniformity > 0.8) {
                    // Mostly grid-based with slight jitter
                    this.generateGridSites(count, uniformity, random);
                } else if (uniformity < 0.2) {
                    // Mostly random with Lloyd relaxation
                    this.generateRandomSites(count, minDistance, random);
                } else {
                    // Hybrid approach
                    this.generateHybridSites(count, uniformity, minDistance, random);
                }
                
                return this.sites;
            }
            
            generateGridSites(count, uniformity, random) {
                const cols = Math.ceil(Math.sqrt(count * this.width / this.height));
                const rows = Math.ceil(count / cols);
                const cellW = this.width / cols;
                const cellH = this.height / rows;
                
                const jitter = (1 - uniformity) * 0.4; // Max 40% jitter
                
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        if (this.sites.length >= count) break;
                        
                        const baseX = (col + 0.5) * cellW;
                        const baseY = (row + 0.5) * cellH;
                        
                        const offsetX = (random.next() - 0.5) * cellW * jitter;
                        const offsetY = (random.next() - 0.5) * cellH * jitter;
                        
                        this.sites.push(new Vec2(
                            Math.max(0, Math.min(this.width, baseX + offsetX)),
                            Math.max(0, Math.min(this.height, baseY + offsetY))
                        ));
                    }
                }
            }
            
            generateRandomSites(count, minDistance, random) {
                const maxAttempts = count * 50;
                let attempts = 0;
                
                while (this.sites.length < count && attempts < maxAttempts) {
                    const candidate = new Vec2(
                        random.range(0, this.width),
                        random.range(0, this.height)
                    );
                    
                    // Check minimum distance
                    let valid = true;
                    for (const site of this.sites) {
                        if (site.distanceTo(candidate) < minDistance) {
                            valid = false;
                            break;
                        }
                    }
                    
                    if (valid) {
                        this.sites.push(candidate);
                    }
                    attempts++;
                }
                
                // Fill remaining with any valid position if we hit max attempts
                while (this.sites.length < count) {
                    this.sites.push(new Vec2(
                        random.range(0, this.width),
                        random.range(0, this.height)
                    ));
                }
                
                // Apply Lloyd relaxation for better distribution
                this.lloydRelaxation(2);
            }
            
            generateHybridSites(count, uniformity, minDistance, random) {
                // Start with grid
                const gridCount = Math.floor(count * uniformity);
                const randomCount = count - gridCount;
                
                this.generateGridSites(gridCount, 0.9, random);
                
                // Add random sites
                const maxAttempts = randomCount * 30;
                let attempts = 0;
                
                while (this.sites.length < count && attempts < maxAttempts) {
                    const candidate = new Vec2(
                        random.range(0, this.width),
                        random.range(0, this.height)
                    );
                    
                    let valid = true;
                    const checkDist = minDistance * (1 - uniformity * 0.5);
                    
                    for (const site of this.sites) {
                        if (site.distanceTo(candidate) < checkDist) {
                            valid = false;
                            break;
                        }
                    }
                    
                    if (valid) {
                        this.sites.push(candidate);
                    }
                    attempts++;
                }
                
                while (this.sites.length < count) {
                    this.sites.push(new Vec2(
                        random.range(0, this.width),
                        random.range(0, this.height)
                    ));
                }
            }
            
            // Lloyd relaxation: move sites to centroids of their Voronoi cells
            lloydRelaxation(iterations) {
                for (let iter = 0; iter < iterations; iter++) {
                    const cells = this.computeVoronoiCells();
                    
                    for (let i = 0; i < this.sites.length; i++) {
                        if (cells[i] && cells[i].length > 0) {
                            const centroid = this.computeCentroid(cells[i]);
                            this.sites[i] = centroid;
                        }
                    }
                }
            }
            
            // Compute Voronoi cells using pixel-based approach
            computeVoronoiCells() {
                const cells = Array(this.sites.length).fill(null).map(() => []);
                
                // Sample points on a grid
                const step = 5; // Sample every 5 pixels for efficiency
                
                for (let y = 0; y < this.height; y += step) {
                    for (let x = 0; x < this.width; x += step) {
                        const point = new Vec2(x, y);
                        let nearest = 0;
                        let minDist = Infinity;
                        
                        for (let i = 0; i < this.sites.length; i++) {
                            const dist = point.distanceTo(this.sites[i]);
                            if (dist < minDist) {
                                minDist = dist;
                                nearest = i;
                            }
                        }
                        
                        cells[nearest].push(point);
                    }
                }
                
                return cells;
            }
            
            computeCentroid(points) {
                let sumX = 0;
                let sumY = 0;
                
                for (const p of points) {
                    sumX += p.x;
                    sumY += p.y;
                }
                
                return new Vec2(
                    Math.max(0, Math.min(this.width, sumX / points.length)),
                    Math.max(0, Math.min(this.height, sumY / points.length))
                );
            }
            
            getSites() {
                return this.sites;
            }
        }

        // ============================================================================
        // Module: CellSegmenter
        // Creates cell regions and extracts colors from source image
        // ============================================================================
        class CellSegmenter {
            constructor(width, height, imageData) {
                this.width = width;
                this.height = height;
                this.imageData = imageData;
                this.cellMap = null; // Pixel to cell index mapping
                this.cells = null; // Cell data including colors
            }
            
            // Compute which cell each pixel belongs to
            computeCellMap(sites) {
                this.cellMap = new Uint16Array(this.width * this.height);
                
                // For each pixel, find nearest site
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        let nearest = 0;
                        let minDist = Infinity;
                        
                        for (let i = 0; i < sites.length; i++) {
                            const dx = x - sites[i].x;
                            const dy = y - sites[i].y;
                            const dist = dx * dx + dy * dy; // Squared distance is fine for comparison
                            
                            if (dist < minDist) {
                                minDist = dist;
                                nearest = i;
                            }
                        }
                        
                        this.cellMap[y * this.width + x] = nearest;
                    }
                }
                
                return this.cellMap;
            }
            
            // Extract average color and bounds for each cell
            extractCellData(sites) {
                this.cells = sites.map((site, index) => ({
                    site,
                    index,
                    pixels: [],
                    color: { r: 0, g: 0, b: 0 },
                    bounds: { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity }
                }));
                
                const data = this.imageData.data;
                
                // Accumulate pixel colors for each cell
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const mapIdx = y * this.width + x;
                        const cellIdx = this.cellMap[mapIdx];
                        const pixelIdx = mapIdx * 4;
                        
                        const cell = this.cells[cellIdx];
                        
                        cell.color.r += data[pixelIdx];
                        cell.color.g += data[pixelIdx + 1];
                        cell.color.b += data[pixelIdx + 2];
                        cell.pixels.push({ x, y });
                        
                        // Update bounds
                        cell.bounds.minX = Math.min(cell.bounds.minX, x);
                        cell.bounds.minY = Math.min(cell.bounds.minY, y);
                        cell.bounds.maxX = Math.max(cell.bounds.maxX, x);
                        cell.bounds.maxY = Math.max(cell.bounds.maxY, y);
                    }
                }
                
                // Compute average colors
                for (const cell of this.cells) {
                    const count = cell.pixels.length;
                    if (count > 0) {
                        cell.color.r = Math.round(cell.color.r / count);
                        cell.color.g = Math.round(cell.color.g / count);
                        cell.color.b = Math.round(cell.color.b / count);
                    }
                }
                
                return this.cells;
            }
            
            getCellMap() {
                return this.cellMap;
            }
            
            getCells() {
                return this.cells;
            }
        }

        // ============================================================================
        // Module: ImageLoader
        // Handles image upload, validation, and preprocessing
        // ============================================================================
        class ImageLoader {
            constructor() {
                this.currentImage = null;
                this.maxDimension = 1024; // Limit for performance
            }
            
            async loadFromFile(file) {
                if (!file.type.startsWith('image/')) {
                    throw new Error('Invalid file type. Please upload an image.');
                }
                
                const img = await this.createImageFromFile(file);
                this.currentImage = await this.preprocessImage(img);
                return this.currentImage;
            }
            
            createImageFromFile(file) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    const url = URL.createObjectURL(file);
                    
                    img.onload = () => {
                        URL.revokeObjectURL(url);
                        resolve(img);
                    };
                    
                    img.onerror = () => {
                        URL.revokeObjectURL(url);
                        reject(new Error('Failed to load image'));
                    };
                    
                    img.src = url;
                });
            }
            
            async preprocessImage(img) {
                // Resize if needed while maintaining aspect ratio
                let width = img.width;
                let height = img.height;
                
                if (width > this.maxDimension || height > this.maxDimension) {
                    const scale = this.maxDimension / Math.max(width, height);
                    width = Math.floor(width * scale);
                    height = Math.floor(height * scale);
                }
                
                // Create canvas and draw resized image
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                
                // Get image data for processing
                const imageData = ctx.getImageData(0, 0, width, height);
                
                return {
                    canvas,
                    imageData,
                    width,
                    height,
                    originalWidth: img.width,
                    originalHeight: img.height
                };
            }
            
            getCurrentImage() {
                return this.currentImage;
            }
        }

        // ============================================================================
        // Module: CanvasRenderer
        // Handles WebGL/Canvas rendering operations
        // ============================================================================
        class CanvasRenderer {
            constructor(canvasElement) {
                this.canvas = canvasElement;
                this.ctx = canvasElement.getContext('2d', { alpha: false });
                this.currentImageData = null;
            }
            
            resize(width, height) {
                this.canvas.width = width;
                this.canvas.height = height;
            }
            
            clear() {
                this.ctx.fillStyle = '#0a0a0a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            drawImageData(imageData) {
                this.currentImageData = imageData;
                this.resize(imageData.width, imageData.height);
                this.ctx.putImageData(imageData, 0, 0);
            }
            
            drawProcessedImage(processedImage) {
                this.resize(processedImage.width, processedImage.height);
                this.ctx.drawImage(processedImage.canvas, 0, 0);
            }
            
            getCanvas() {
                return this.canvas;
            }
        }

        // ============================================================================
        // Module: UIController
        // Manages UI interactions and state
        // ============================================================================
        class UIController {
            constructor() {
                this.uploadArea = document.getElementById('uploadArea');
                this.fileInput = document.getElementById('fileInput');
                this.uploadStatus = document.getElementById('uploadStatus');
                this.imageInfo = document.getElementById('imageInfo');
                this.glassSection = document.getElementById('glassSection');
                this.processStatus = document.getElementById('processStatus');
                
                // Slider elements
                this.sliders = {
                    edgeSensitivity: document.getElementById('edgeSensitivity'),
                    edgeBlur: document.getElementById('edgeBlur'),
                    minRegionArea: document.getElementById('minRegionArea'),
                    maxRegionArea: document.getElementById('maxRegionArea'),
                    subdivDensity: document.getElementById('subdivDensity'),
                    subdivRandom: document.getElementById('subdivRandom'),
                    borderThickness: document.getElementById('borderThickness'),
                    borderIrregularity: document.getElementById('borderIrregularity'),
                    borderDepth: document.getElementById('borderDepth'),
                    borderSoftness: document.getElementById('borderSoftness'),
                    borderBrightness: document.getElementById('borderBrightness')
                };
                
                this.sliderValues = {
                    edgeSensitivity: document.getElementById('edgeSensitivityValue'),
                    edgeBlur: document.getElementById('edgeBlurValue'),
                    minRegionArea: document.getElementById('minRegionAreaValue'),
                    maxRegionArea: document.getElementById('maxRegionAreaValue'),
                    subdivDensity: document.getElementById('subdivDensityValue'),
                    subdivRandom: document.getElementById('subdivRandomValue'),
                    borderThickness: document.getElementById('borderThicknessValue'),
                    borderIrregularity: document.getElementById('borderIrregularityValue'),
                    borderDepth: document.getElementById('borderDepthValue'),
                    borderSoftness: document.getElementById('borderSoftnessValue'),
                    borderBrightness: document.getElementById('borderBrightnessValue')
                };
                
                this.regenerateBtn = document.getElementById('regenerateBtn');
                this.updateBordersBtn = document.getElementById('updateBordersBtn');
                
                this.onImageUpload = null;
                this.onRegenerate = null;
                this.onUpdateBorders = null;
                
                this.initializeEventListeners();
            }
            
            initializeEventListeners() {
                // File input change
                this.fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.handleFile(e.target.files[0]);
                    }
                });
                
                // Drag and drop
                this.uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    this.uploadArea.classList.add('dragging');
                });
                
                this.uploadArea.addEventListener('dragleave', () => {
                    this.uploadArea.classList.remove('dragging');
                });
                
                this.uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    this.uploadArea.classList.remove('dragging');
                    
                    if (e.dataTransfer.files.length > 0) {
                        this.handleFile(e.dataTransfer.files[0]);
                    }
                });
                
                // Slider updates
                Object.entries(this.sliders).forEach(([key, slider]) => {
                    slider.addEventListener('input', (e) => {
                        this.updateSliderValue(key, e.target.value);
                    });
                });
                
                // Regenerate button
                this.regenerateBtn.addEventListener('click', () => {
                    if (this.onRegenerate) {
                        this.onRegenerate();
                    }
                });
                
                // Update borders button
                this.updateBordersBtn.addEventListener('click', () => {
                    if (this.onUpdateBorders) {
                        this.onUpdateBorders();
                    }
                });
            }
            
            updateSliderValue(key, value) {
                let display = value;
                if (key === 'edgeSensitivity' || key === 'subdivDensity' || 
                    key === 'subdivRandom' || key === 'borderIrregularity' || 
                    key === 'borderDepth' || key === 'borderSoftness' || 
                    key === 'borderBrightness') {
                    display = parseFloat(value).toFixed(2);
                } else if (key === 'borderThickness' || key === 'edgeBlur') {
                    display = parseFloat(value).toFixed(1);
                }
                this.sliderValues[key].textContent = display;
            }
            
            async handleFile(file) {
                this.updateStatus('Loading image...', 'loading');
                
                try {
                    if (this.onImageUpload) {
                        await this.onImageUpload(file);
                    }
                } catch (error) {
                    this.updateStatus(`Error: ${error.message}`, 'error');
                    console.error(error);
                }
            }
            
            updateStatus(message, type = 'info') {
                this.uploadStatus.textContent = message;
                this.uploadStatus.style.color = type === 'error' ? '#ff6b6b' : 
                                                 type === 'loading' ? '#4a9eff' : '#888';
            }
            
            updateProcessStatus(message, type = 'info') {
                this.processStatus.textContent = message;
                this.processStatus.style.color = type === 'error' ? '#ff6b6b' : 
                                                  type === 'loading' ? '#4a9eff' : '#88cc88';
            }
            
            updateImageInfo(imageData) {
                this.imageInfo.innerHTML = `
                    <div>Dimensions: ${imageData.width} Ã— ${imageData.height}px</div>
                    <div>Original: ${imageData.originalWidth} Ã— ${imageData.originalHeight}px</div>
                    <div>Ready for processing</div>
                `;
            }
            
            showGlassControls() {
                this.glassSection.style.display = 'block';
                this.borderSection.style.display = 'block';
            }
            
            getSegmentationParams() {
                return {
                    edgeSensitivity: parseFloat(this.sliders.edgeSensitivity.value),
                    edgeBlur: parseFloat(this.sliders.edgeBlur.value),
                    minRegionArea: parseInt(this.sliders.minRegionArea.value),
                    maxRegionArea: parseInt(this.sliders.maxRegionArea.value),
                    subdivDensity: parseFloat(this.sliders.subdivDensity.value),
                    subdivRandom: parseFloat(this.sliders.subdivRandom.value)
                };
            }
            
            getBorderParams() {
                return {
                    borderThickness: parseFloat(this.sliders.borderThickness.value),
                    borderIrregularity: parseFloat(this.sliders.borderIrregularity.value),
                    borderDepth: parseFloat(this.sliders.borderDepth.value),
                    borderSoftness: parseFloat(this.sliders.borderSoftness.value),
                    borderBrightness: parseFloat(this.sliders.borderBrightness.value)
                };
            }
            
            setImageUploadCallback(callback) {
                this.onImageUpload = callback;
            }
            
            setRegenerateCallback(callback) {
                this.onRegenerate = callback;
            }
            
            setUpdateBordersCallback(callback) {
                this.onUpdateBorders = callback;
            }
            
            setProcessing(isProcessing) {
                this.regenerateBtn.disabled = isProcessing;
                Object.values(this.sliders).forEach(slider => {
                    slider.disabled = isProcessing;
                });
            }
        }

        // ============================================================================
        // Module: Application
        // Main application controller
        // ============================================================================
        class StainedGlassApp {
            constructor() {
                this.imageLoader = new ImageLoader();
                this.renderer = new CanvasRenderer(document.getElementById('renderCanvas'));
                this.ui = new UIController();
                
                // Processing modules (created after image load)
                this.segmenter = null;
                this.glassRenderer = null;
                
                // Current state
                this.currentImage = null;
                this.currentCells = null;
                this.currentCellMap = null;
                this.randomSeed = Date.now();
                
                this.initialize();
            }
            
            initialize() {
                // Set up UI callbacks
                this.ui.setImageUploadCallback(async (file) => {
                    await this.handleImageUpload(file);
                });
                
                this.ui.setRegenerateCallback(() => {
                    this.generateStainedGlass();
                });
                
                this.ui.setUpdateBordersCallback(() => {
                    this.updateBorders();
                });
                
                console.log('Stained Glass App initialized - Phase 3.5: Edge-Aware Segmentation');
            }
            
            async handleImageUpload(file) {
                try {
                    // Load and preprocess image
                    this.currentImage = await this.imageLoader.loadFromFile(file);
                    
                    // Display original on canvas temporarily
                    this.renderer.drawProcessedImage(this.currentImage);
                    
                    // Update UI
                    this.ui.updateStatus('Image loaded successfully', 'info');
                    this.ui.updateImageInfo(this.currentImage);
                    this.ui.showGlassControls();
                    
                    // Initialize processing modules with new edge-aware segmenter
                    this.segmenter = new RegionSegmenter(
                        this.currentImage.width,
                        this.currentImage.height,
                        this.currentImage.imageData
                    );
                    
                    this.glassRenderer = new StainedGlassRenderer(
                        document.getElementById('renderCanvas')
                    );
                    
                    // Generate initial stained glass
                    this.generateStainedGlass();
                    
                } catch (error) {
                    throw error;
                }
            }
            
            generateStainedGlass() {
                if (!this.currentImage) return;
                
                this.ui.setProcessing(true);
                this.ui.updateProcessStatus('Segmenting image...', 'loading');
                
                // Use setTimeout to allow UI to update
                setTimeout(() => {
                    try {
                        const params = this.ui.getSegmentationParams();
                        params.seed = this.randomSeed;
                        
                        console.log('Generating stained glass with edge-aware segmentation:', params);
                        const startTime = performance.now();
                        
                        // Step 1: Edge-aware segmentation (replaces Voronoi generation)
                        const { cells, cellMap } = this.segmenter.segment(params);
                        
                        this.currentCells = cells;
                        this.currentCellMap = cellMap;
                        
                        console.log(`Segmentation complete: ${cells.length} regions`);
                        
                        // Step 2: Initialize border renderer
                        this.glassRenderer.initializeBorderRenderer(
                            this.currentImage.width,
                            this.currentImage.height,
                            this.randomSeed
                        );
                        
                        // Invalidate border cache since cells changed
                        this.glassRenderer.invalidateBorderCache();
                        
                        // Step 3: Render stained glass with enhanced borders
                        const borderParams = this.ui.getBorderParams();
                        this.glassRenderer.renderWithBorders(
                            this.currentImage.width,
                            this.currentImage.height,
                            this.currentCells,
                            this.currentCellMap,
                            borderParams
                        );
                        
                        const elapsed = performance.now() - startTime;
                        console.log(`Rendering complete in ${elapsed.toFixed(0)}ms`);
                        
                        this.ui.updateProcessStatus(
                            `Generated ${this.currentCells.length} glass pieces in ${elapsed.toFixed(0)}ms`,
                            'info'
                        );
                        
                    } catch (error) {
                        console.error('Error generating stained glass:', error);
                        this.ui.updateProcessStatus(`Error: ${error.message}`, 'error');
                    } finally {
                        this.ui.setProcessing(false);
                    }
                }, 10);
            }
            
            updateBorders() {
                if (!this.currentImage || !this.currentCells || !this.currentCellMap) {
                    console.log('No glass to update');
                    return;
                }
                
                this.ui.updateProcessStatus('Updating borders...', 'loading');
                
                // Use setTimeout for UI responsiveness
                setTimeout(() => {
                    try {
                        const startTime = performance.now();
                        
                        // Get updated border parameters
                        const borderParams = this.ui.getBorderParams();
                        
                        // Re-render with new border settings (keeps existing distance field)
                        this.glassRenderer.renderWithBorders(
                            this.currentImage.width,
                            this.currentImage.height,
                            this.currentCells,
                            this.currentCellMap,
                            borderParams
                        );
                        
                        const elapsed = performance.now() - startTime;
                        console.log(`Borders updated in ${elapsed.toFixed(0)}ms`);
                        
                        this.ui.updateProcessStatus(
                            `Borders updated in ${elapsed.toFixed(0)}ms`,
                            'info'
                        );
                        
                    } catch (error) {
                        console.error('Error updating borders:', error);
                        this.ui.updateProcessStatus(`Error: ${error.message}`, 'error');
                    }
                }, 10);
            }
        }

        // ============================================================================
        // Initialize Application
        // ============================================================================
        const app = new StainedGlassApp();
    </script>
</body>
</html>
